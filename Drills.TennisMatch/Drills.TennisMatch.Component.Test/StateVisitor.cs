using System;
using System.Diagnostics;

namespace Drills.TennisMatch.Component.Test
{
    /// <summary>
    /// All the possible states of a Tennis Match can be generated by a sequence of actions PointToPlayer1 | PointToPlayer2.
    /// The sequence ends when the Match is in state Finished.
    /// This can be represented by a binary tree where the terminal leaves are always the Finished state.
    /// To test each possible state of the Match, a recursive Visitor pattern can be applied to this tree.
    /// </summary>
    public class StateVisitor
    {
        public static Match NewMatch = LiveMatch.Start(p1Serves: true);

        public StateVisitor() { }

        public void ApplyTest(Match state, Action<LiveMatch> testLiveMatch, Action<WonMatch> testWonMatch)
        {
            bool IsNotInfiniteBranch(Match nextState) =>
                nextState.Match(
                          live => live.Set.Game.Points
                                      .Match(
                                      loveAll => true,
                                      pair => true,
                                      deuce => false, // Don´t go back to Deuce again.
                                      advantage => true,
                                      win => true),
                          finished => true);

            state.Match(
                  liveMatch =>
                  {
                      Trace.WriteLine("LiveMatch");

                      testLiveMatch(liveMatch);

                      var nextToP1 = liveMatch.PointTo(true);
                      var nextToP2 = liveMatch.PointTo(false);

                      void ApplyBoth()
                      {
                          ApplyTest(nextToP1, testLiveMatch, testWonMatch);
                          ApplyTest(nextToP2, testLiveMatch, testWonMatch);
                      }

                      liveMatch.Set.Game.Points
                               .Match(
                                loveAll => ApplyBoth(),
                                pair => ApplyBoth(),
                                deuce => ApplyBoth(),
                                advantage =>
                                {
                                    if (IsNotInfiniteBranch(nextToP1))
                                    {
                                        ApplyTest(nextToP1, testLiveMatch, testWonMatch);
                                    }
                                    if (IsNotInfiniteBranch(nextToP2))
                                    {
                                        ApplyTest(nextToP2, testLiveMatch, testWonMatch);
                                    }
                                },
                                win => ApplyBoth());
                  },
                  wonMatch =>
                  {
                      Trace.WriteLine("FinishedMatch");
                      testWonMatch(wonMatch);
                  });
        }
    }
}
