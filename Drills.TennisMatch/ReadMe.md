# Introduction

A C# solution for the TennisMatch score exercise. Includes,

1. Score component in Functional Programming flavour using,
    - immutability,
    - ad hoc union types with strict type matching in compile type,
    - symbol types aka safe enums.
2. A WPF UI with standard MVVM.
2. Unit tests based on,
    - property testing,
    - a recursive Visitor pattern to traverse and test all the possible states generated by the score component.


# A two fold problem

A TennisMatch can be represented as a sequence of states where the next state is generated by only one of two actions,
1. PointToPlayer1.
2. PointToPlayer2.

In each state, the Match is an aggregate of different scoring artifacts,
1. A Match is composed of a sequence of Sets.
2. A Set is composed of a sequence of Games.
3. A Game is composed of a sequence of Points.
4. A Point has a limited set of sequenced values.

An application that displays a TennisScoreBoard must be able to,
1. handle sequences of this artifacts,
2. access each score artifact in a uniform way.
3. ensure that state transitions in each artifact respect the TennisScore rules,
    - a Deuce can only go to Advantage,
    - an Advantage can go to a Win or Deuce,
    - a finished Game cannot be advanced,
    - etc.

## Problem 1

C#´s default tool to build a unified type system is polymorphism so for example, we can do things like iterate through a collection of games and process them in the UI.

The catch here is that the different scoring artifacts, Point, Game, Set and Match are not naturally polymorphic,
1. Point scores,
   - LoveAll and Deuce are constants, 
   - Advantage and WinnerPoints are "one of 2" (advantage to P1, win to P2, etc.),
   - The rest are pairs of numbers.
   - Love, NumericPairs, Deuce and Advantage can be advanced to a Next state.
   - WinnerPoints cannot be advanced as it is a final state.
   - *How do we unify them under a single type?*
2. Game, Set and Match,
   - All of them can be in 2 states, Live (on going) or Won (finished).
   - State Live allows advancing the Match with actions PointToP1 or PointToP2.
   - Sets have State Tiebreak which allows advancing to Won but also going back to Live.
   - State Won does not allows advancing the Match, it´s essentially a snapshot containing the sequence of the scores.
   - *How do we unify them under a single type?*

Since these artifacts have almost no common properties or actions that can be abstracted, the only way to work with them is to do things like,
1. Runtime condition testing: IsDeuce()?, IsLoveAll()?, Game.IsFinished()? etc.
   This is a leaky abstraction as it requires checking conditions that might fail during runtime.
   It also forces the API user to be aware of these conditions.
2. Runtime type matching: point is Deuce, point is Love, etc.
   This a bit better as it does not require different score artifacts to implement common properties or actions.
   However, it requires runtime type matching which is usually recognized as an anti-pattern because,
   - type matching is not exhaustive in compile time so unchecked cases might fail silently in runtime,
   - someone might inadvertently change the inheritance, interfaces, etc. and break type matches already written.
     Again, this would fail silently in runtime and might lead to bugs very difficult to pinpoint.
    
## Solution 1

The proposed solution is based on Union Types aka Discriminated Union, Sum Types or Variant Records. 
C# does not support this kind of type so a ad hoc implementation of Union has been created from scratch.

Union is generic type and allows to define type cases,

```C#
Union<T1, T2>
Union<T1, T2, T3>
etc.
```

The value of a Union cannot be accesed directly, it requires pattern matching on the types,

```C#
var result = unionOf3.Match(
                      t1 => "t1",
                      t2 => "t2",
                      t3 => "t3")

```
 
Applied to the TennisScore case,

- The possible states of a PointScore are defined as 

```C#
    Union<LoveAll, PairPoints, Deuce, Advantange, WinPoints>
```
- Game, Set and Match share commons states and can be represented as,
```C#
    Game: Union<LiveGame, WonGame>

    Set: Union<LiveSet, WonSet>
    
    Match: Union<LiveMatch, WonMatch>
```

Using a Union pattern, all the possible types that a Union object can have are enforced in compile time.
This pattern greatly improves the safety of the code and allows us to catch many errors early in compile time instead on run time.
For example, with regular type matching,

```C#
    // Verbose and ugly.
    if(tennisMatch.GetType() == typeof(LiveMatch))
    {
        HandleLiveMatch(); 
	}
    else if(tennisM.GetType() == typeof(WonMatch))
    {
        FinishMatch();
    }
    else
    {
        // Eg. if someone adds a new type NewMatch, these ifs will still build correctly.
        // We will only find out there is an unhandled case in run time, a surprise better avoided.
        throw Exception("Not supported case");
    }
```
Compare this to strict matching with Union,

```C#
    tennisMatch.Match(
        liveGame => ...        
        wonGame => ...
	);
```
If someone adds a new case to Match,

```C#
    Match: Union<NewMatch, LiveMatch, WonMatch>
```
the previous Match will not compile and have to be fixed,

```C#
    tennisMatch.Match(
        newGame => ...
        liveGame => ...        
        wonGame => ...
	);
```

## Problem 2
How do we create exhaustive tests?
A Match contains many possible states resulting from a sequence of actions PointToP1 or PointToP2.
The only way to have good coverage is to test each these state.

## Solution 2
The most straightforward way to be exhaustive is to generate all the states procedurally.

Since each state results from a binary operation, PointToP1 or PointToP2, all the possible states can be simulated with a binary tree.

This creates two questions,
1. How do we traverse this tree of states while running tests on each state?
2. We would like to test Points, Games, Sets and Match separately. How do we test different parts of the application in each state? 

A solution to these questions is traversing all the possible states of a TennisMatch using a recursive Visitor pattern.

No tree data structure is necessary, only a recursive function that explores all the possible branches of execution of PointToP1 and PointToP2.

To achieve this, a StateVisitor has been created,

```C#
    var stateVisitor = new StateVisitor();

    stateVisitor.ApplyTest(StateVisitor.NewMatch,
        liveMatch =>
        {
            // Any test can be applied here on Match, Game, Set, Point states.
        },
        wonMatch =>
        {
            // Any test can be applied here on Match, Game, Set, Point states.

        });
```

The StateVisitor culls branches going from Advantage to Deuce as they can lead to infinite recursion.

# Design

The Component has been designed as an Immutable State Machine with an aggregate root, Match. That is, 
- Match is the root of nested data (Sets, Games and Points).
- Match only has two possible operation: LiveMatch.Start and Match PointTo(bool isp1).
- Once a Match is started, every call to PointTo generates a new instance of the Match.

There is no mutable state, which has important benefits,
- increased safety,
- sharing immutable references is easy and allows using less memory,
- multithreading on read only data is much easier,
- in the case of testing, the StateVisitor would not be possible with a mutable Match.

Business rules are modelled delegating as much as possible on the type system, with the goal of making illegal states not representable.

# Testing

The StateVisitor seems to running correctly but there is an unexpected issue, the number of generated states is too for unit test to finish in a reasonable amount of time.
Prior to implementation, I did not estimate the asymptotic O(n) cost of a TennisMatch. 
Combinatorially speaking,
1. Let the Length of a Match be the total number of points scored.
2. Then the number of possible sequences of scores in a Match is a function of the summatory of the number of variations of 2 (P1 wins or P2 wins) on all possible Lengths of a Match.

In summary, as it is, the StateVisitor is exhaustive but too expensive to be run in unit tests.
Pending further analysis to find out a way to make this pattern computationally viable for unit testing.

# API

The Components is accessible by a single entry point, 

```C#
var tennisMatch = LiveMatch.Start(bool p1Serves)
```

which returns an object of type Match. Match is a union of LiveMatch and WonMatch.

The only way to access the return Match is via pattern matching (unfortunate coincidence of words),
```C#
tennisMatch.Match(
    liveMatch => ..., // Handle LiveMatch object
    wonMatch => ..., // Handle WonMatch object
)
```

Both LiveMatch and WonMatch are root aggregates.

A LiveMatch contains,
- a LiveSet representing the current set in play,
- a sequence of WonSets.

A WonMatch contains,
- a sequence of WonSets,
- the Total score of Sets (P1, P2).

Going further down the aggregate data, the structure repeats itself.

A LiveSet contains,
- a LiveGame representing the current game in play,
- a sequence of WonGames.

A WonSet contains,
- a sequence of WonGames,
- the Total score of Games (P1, P2).

A LiveGame contains,
- a PointsScore representing the current point score,
- a sequence of PointScores.
- who is serving and who is receiving, P1Serves (true if P1 serves and P2 receives, false in the reverse case).

A WonGame contains,
- a sequence of PointScores,
- the winner of the Game, P1Wins (true if P1 wins, false if P2 wins).
- who is serving and who is receiving, P1Serves (true if P1 serves and P2 receives, false in the reverse case).

All of these are nested data in the root Match and can be traversed with pattern matching.
While initially being forced to do matching all the time may seem a nuisance, it is actually a great benefit.
It forces us to handle cases correctly, using again the example above,
```C#
tennisMatch.Match(
    liveMatch => liveMatch.PointTo(isP1: true), // We can advance a point for P1.
    wonMatch => ..., // It is impossible to call wonMatch.PointTo as it does not exist.
                     // This is enforced in compile time, with regular polymorphism 
                     // we could not have this kind of strict checks.
)
```

# Credits

For making the lives of developers easier, many thanks to the creator the awesome DSEG Font.

DSEG Font is available at https://www.keshikan.net/fonts-e.html under the SIL Open Font License (OFL) http://scripts.sil.org/OFL.
